# dcp_invariants.sage
# Assumes dcp_common.sage is loaded

def compute_invariants_from_generators(C, triples, Vbasis, generators, cache_name):
    """Compute invariants under a subgroup generated by `generators`."""
    cp = cache_path(cache_name)
    if CACHE_PRECOMPUTE and os.path.exists(cp):
        log(f"Loading invariants ({cache_name}) from cache...")
        return load(cp)

    dimV, Wdim = Vbasis.nrows(), Vbasis.ncols()

    def sign_sort(triple):
        arr = list(triple)
        sign = 1
        for i in range(2):
            for j in range(2-i):
                if arr[j] > arr[j+1]:
                    arr[j], arr[j+1] = arr[j+1], arr[j]
                    sign = -sign
        return sign, tuple(arr)

    B = matrix(QQ, Wdim, dimV, sparse=True)
    for j in range(dimV):
        for i, val in vector(QQ, Vbasis.row(j)).dict().items():
            B[i, j] = val

    chan_index = {C[i]: i for i in range(len(C))}
    triple_to_row = {triples[i]: i for i in range(len(triples))}

    # Use _perm_ch from dcp_common (expects 2 args: ch, p)
    # But locally in 54.sage it was different. 
    # Let's rely on _perm_ch in dcp_common which is:
    # def _perm_ch(ch, p):
    #     if len(ch) == 2: ...
    #     return canonical_three_subset(...)
    
    for t, perm in enumerate(generators):
        img_row, img_sgn = [0]*len(triples), [0]*len(triples)
        for i, tri in enumerate(triples):
            imgs = [chan_index[_perm_ch(C[idx], perm)] for idx in tri]
            if len(set(imgs)) < 3:
                img_row[i], img_sgn[i] = i, 0
            else:
                sgn, tri2 = sign_sort(tuple(imgs))
                img_row[i], img_sgn[i] = triple_to_row[tri2], sgn

        PB = matrix(QQ, Wdim, B.ncols(), sparse=True)
        for (r, c), val in B.dict().items():
            if img_sgn[r]:
                PB[img_row[r], c] += img_sgn[r] * val

        # OPTIMIZATION: Use fast_right_kernel
        diff = PB - B
        kernel_basis = fast_right_kernel(diff)
        B = B * kernel_basis.transpose()
        log(f"  subgroup gen {t+1}/{len(generators)}: dim = {B.ncols()}")

    result = [B.column(i) for i in range(B.ncols())]
    if CACHE_PRECOMPUTE:
        save(result, cp)
    return result

def compute_S6_invariants(C, triples, Vbasis):
    cp = cache_path(CACHE_INVARIANTS_FILE)
    if CACHE_PRECOMPUTE and os.path.exists(cp):
        log("Loading S6 invariants from cache...")
        return load(cp)
    
    # S6 is generated by transpositions (i, i+1)
    gens = [SymmetricGroup(6)((i, i+1)) for i in range(1, 6)]
    # We can reuse the generalized function with a specific cache name
    # But 54.sage implemented it inline. Let's use the generalized one if possible.
    # The cache name in 54.sage was CACHE_INVARIANTS_FILE ("invariants.sobj")
    # compute_invariants_from_generators takes cache_name
    
    return compute_invariants_from_generators(C, triples, Vbasis, gens, CACHE_INVARIANTS_FILE)

def compute_boundary_stabilizer_invariants(C, triples, Vbasis, mode='S3xS3'):
    """Invariants under subgroup that preserves the (123)|(456) split."""
    gens = []
    gens.append(SymmetricGroup(6)((1,2)))
    gens.append(SymmetricGroup(6)((2,3)))
    gens.append(SymmetricGroup(6)((4,5)))
    gens.append(SymmetricGroup(6)((5,6)))
    cache_name = "invariants_S3xS3.sobj"
    if mode == 'S3xS3Z2':
        gens.append(SymmetricGroup(6)([(1,4), (2,5), (3,6)]))
        cache_name = "invariants_S3xS3Z2.sobj"
    return compute_invariants_from_generators(C, triples, Vbasis, gens, cache_name)

def verify_dim1_candidate(alpha0, Vinv_final, Tmat, C, triples, Vbasis, 
                         check_hodge=False, save_path=None):
    log("\n" + "="*70)
    log("DIMENSION-1 CANDIDATE VERIFICATION")
    log("="*70)
    
    final_dim = len(Vinv_final)
    
    if final_dim != 1:
        log(f"  WARNING: Expected dim=1, but got dim={final_dim}")
        return {
            'status': 'dimension_mismatch',
            'expected_dim': 1,
            'actual_dim': final_dim
        }
    
    log(f"  ✓ Dimension check: dim = {final_dim} (correct)")
    
    cand_vec = build_candidate_vec(alpha0, Vinv_final)
    
    if cand_vec is None:
        log("  ✗ Failed to build candidate vector")
        return {'status': 'error', 'reason': 'failed_to_build_candidate'}
    
    log(f"  ✓ Candidate vector built (length={len(cand_vec)})")
    
    nz = alpha_support(alpha0)
    log(f"  ✓ Alpha support: {len(nz)} nonzero coefficients")
    if len(nz) <= 20:
        log(f"    Nonzero indices: {[i for i,a in nz]}")
    
    result = {
        'status': 'verified',
        'dimension': final_dim,
        'alpha_nnz': len(nz),
        'alpha_support': [(int(i), str(a)) for i, a in nz[:50]],
        'candidate_vector_length': len(cand_vec),
    }
    
    if check_hodge:
        # Assuming compute_hodge_structure is defined elsewhere or importable
        # In 54.sage it was likely global or imported. 
        # If it's missing, we skip.
        pass 
        # For now, just logging as skipped or todo
        log("  [TODO] Hodge structure check needs compute_hodge_structure")
    else:
        log("  [SKIP] Hodge structure check (set check_hodge=True to enable)")
        result['hodge_structure'] = {'status': 'skipped', 'note': 'Enable with check_hodge=True'}
    
    if save_path:
        try:
            ensure_cache_dir()
            os.makedirs(os.path.dirname(save_path) if os.path.dirname(save_path) else '.', exist_ok=True)
            with open(save_path, 'w') as f:
                json.dump(json_sanitize(result), f, indent=2)
            log(f"  ✓ Saved verification to: {save_path}")
        except Exception as e:
            log(f"  ✗ Failed to save verification: {e}")
    
    log("="*70)
    return result

