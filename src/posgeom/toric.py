from sage.all import Matrix, ZZ, vector, QQ

def compute_lattice_basis(vertices, saturate=True):
    """
    Given a list of integer vectors (vertices) in Z^N,
    computes an affine isomorphism to Z^d (where d is the dimension of the affine span).
    
    Args:
        vertices: List of integer vectors
        saturate (bool): If True, computes the basis for the saturated lattice 
                         of the affine span (intersection of affine span with Z^N).
                         This guarantees we are working on the 'correct' torus for the affine space.
    
    Returns:
        d (int): Dimension
        basis_matrix (Matrix): d x N matrix B (rows are basis vectors)
        origin (vector): Vector v0 in Z^N
        
    Mapping: v (in Z^N) -> u (in Z^d)
    u = B * (v - v0)
    """
    if not vertices:
        raise ValueError("No vertices provided")
        
    dim_ambient = len(vertices[0])
    v0 = vector(ZZ, vertices[0])
    
    # Shift to origin
    shifted = [vector(ZZ, v) - v0 for v in vertices[1:]]
    
    # Create matrix (row vectors)
    if not shifted:
        return 0, Matrix(ZZ, 0, dim_ambient), v0
    
    # Submodule generated by shifted vectors
    submodule = (ZZ**dim_ambient).submodule(shifted)
    
    if saturate:
        # Saturated submodule: includes all integer points in the rational span
        submodule = submodule.saturation()
        
    basis = submodule.basis()
    d = len(basis)
    
    # Basis matrix (d x N) where rows are b_k
    B_ambient = Matrix(basis)
    
    return d, B_ambient, v0

def get_toric_exponents(vertices, basis_matrix, origin):
    """
    Converts ambient vertices to toric exponent vectors u in Z^d.
    Solves (v - v0) = u * B_ambient for u.
    """
    exponents = []
    
    for v in vertices:
        v_vec = vector(ZZ, v)
        delta = v_vec - origin
        
        try:
            # solve_left tries to find x such that x * B = delta
            # We explicitly check for integrality just in case
            u = basis_matrix.solve_left(delta)
            
            # Check if u has integer entries (Sage solve_left on ZZ matrix might return rationals if in field)
            # But since we built the basis from the submodule (or its saturation), 
            # delta MUST be an integer linear combination if v was in the set used to build the basis.
            # However, if 'saturate=False' and we pass a vertex not in the span, it might fail or be rational.
            
            if not all(c in ZZ for c in u):
                 raise ValueError(f"Vertex {v} maps to non-integer coordinates {u}. Basis might not be saturated or vertex is outside lattice.")
                 
            exponents.append(list(u))
        except ValueError:
            raise ValueError(f"Vertex {v} not in lattice span!")
        except ArithmeticError: # Sage might raise this for unsolvable systems
             raise ValueError(f"Vertex {v} not in lattice span!")
            
    return exponents
